//----------------------------------------------------------------------------
//  This file is automatically generated, do not modify.      
//----------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;
using Emgu.CV;
using Emgu.CV.Structure;
using Emgu.Util;

namespace Emgu.CV.ML
{
   public static partial class MlInvoke
   {

     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveDTreesGetMaxCategories(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveDTreesSetMaxCategories(
        IntPtr obj,  
        int val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveDTreesGetMaxDepth(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveDTreesSetMaxDepth(
        IntPtr obj,  
        int val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveDTreesGetMinSampleCount(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveDTreesSetMinSampleCount(
        IntPtr obj,  
        int val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveDTreesGetCVFolds(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveDTreesSetCVFolds(
        IntPtr obj,  
        int val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     [return: MarshalAs(CvInvoke.BoolMarshalType)]
     internal static extern bool cveDTreesGetUseSurrogates(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveDTreesSetUseSurrogates(
        IntPtr obj, 
        [MarshalAs(CvInvoke.BoolMarshalType)] 
        bool val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     [return: MarshalAs(CvInvoke.BoolMarshalType)]
     internal static extern bool cveDTreesGetUse1SERule(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveDTreesSetUse1SERule(
        IntPtr obj, 
        [MarshalAs(CvInvoke.BoolMarshalType)] 
        bool val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     [return: MarshalAs(CvInvoke.BoolMarshalType)]
     internal static extern bool cveDTreesGetTruncatePrunedTree(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveDTreesSetTruncatePrunedTree(
        IntPtr obj, 
        [MarshalAs(CvInvoke.BoolMarshalType)] 
        bool val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern float cveDTreesGetRegressionAccuracy(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveDTreesSetRegressionAccuracy(
        IntPtr obj,  
        float val);
     
   }

   public partial class DTrees
   {

     /// <summary>
     /// Cluster possible values of a categorical variable into K less than or equals maxCategories clusters to find a suboptimal split
     /// </summary>
     public int MaxCategories
     {
        get { return MlInvoke.cveDTreesGetMaxCategories(_ptr); } 
        set { MlInvoke.cveDTreesSetMaxCategories(_ptr, value); }
     }
     
     /// <summary>
     /// The maximum possible depth of the tree
     /// </summary>
     public int MaxDepth
     {
        get { return MlInvoke.cveDTreesGetMaxDepth(_ptr); } 
        set { MlInvoke.cveDTreesSetMaxDepth(_ptr, value); }
     }
     
     /// <summary>
     /// If the number of samples in a node is less than this parameter then the node will not be split
     /// </summary>
     public int MinSampleCount
     {
        get { return MlInvoke.cveDTreesGetMinSampleCount(_ptr); } 
        set { MlInvoke.cveDTreesSetMinSampleCount(_ptr, value); }
     }
     
     /// <summary>
     /// If CVFolds greater than 1 then algorithms prunes the built decision tree using K-fold
     /// </summary>
     public int CVFolds
     {
        get { return MlInvoke.cveDTreesGetCVFolds(_ptr); } 
        set { MlInvoke.cveDTreesSetCVFolds(_ptr, value); }
     }
     
     /// <summary>
     /// If true then surrogate splits will be built
     /// </summary>
     public bool UseSurrogates
     {
        get { return MlInvoke.cveDTreesGetUseSurrogates(_ptr); } 
        set { MlInvoke.cveDTreesSetUseSurrogates(_ptr, value); }
     }
     
     /// <summary>
     /// If true then a pruning will be harsher
     /// </summary>
     public bool Use1SERule
     {
        get { return MlInvoke.cveDTreesGetUse1SERule(_ptr); } 
        set { MlInvoke.cveDTreesSetUse1SERule(_ptr, value); }
     }
     
     /// <summary>
     /// If true then pruned branches are physically removed from the tree
     /// </summary>
     public bool TruncatePrunedTree
     {
        get { return MlInvoke.cveDTreesGetTruncatePrunedTree(_ptr); } 
        set { MlInvoke.cveDTreesSetTruncatePrunedTree(_ptr, value); }
     }
     
     /// <summary>
     /// Termination criteria for regression trees
     /// </summary>
     public float RegressionAccuracy
     {
        get { return MlInvoke.cveDTreesGetRegressionAccuracy(_ptr); } 
        set { MlInvoke.cveDTreesSetRegressionAccuracy(_ptr, value); }
     }
     
   }
}