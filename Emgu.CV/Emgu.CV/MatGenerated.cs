//----------------------------------------------------------------------------
//  This file is automatically generated, do not modify.      
//----------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;
using Emgu.CV;
using Emgu.CV.Structure;
using Emgu.Util;

namespace Emgu.CV
{
   public static partial class CvInvoke
   {

     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     [return: MarshalAs(CvInvoke.BoolMarshalType)]
     internal static extern bool cveMatIsContinuous(IntPtr obj);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     [return: MarshalAs(CvInvoke.BoolMarshalType)]
     internal static extern bool cveMatIsSubmatrix(IntPtr obj);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern CvEnum.DepthType cveMatDepth(IntPtr obj);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     [return: MarshalAs(CvInvoke.BoolMarshalType)]
     internal static extern bool cveMatIsEmpty(IntPtr obj);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveMatNumberOfChannels(IntPtr obj);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveMatPopBack(
        IntPtr obj,  
        int val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveMatPushBack(
        IntPtr obj,  
        IntPtr val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern IntPtr cveMatTotal(IntPtr obj);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveMatGetDims(IntPtr obj);
     
   }

   public partial class Mat
   {

     /// <summary>
     /// True if the data is continues
     /// </summary>
     public bool IsContinuous
     {
        get { return CvInvoke.cveMatIsContinuous(_ptr); } 
     }
     
     /// <summary>
     /// True if the matrix is a submatrix of another matrix
     /// </summary>
     public bool IsSubmatrix
     {
        get { return CvInvoke.cveMatIsSubmatrix(_ptr); } 
     }
     
     /// <summary>
     /// Depth type
     /// </summary>
     public CvEnum.DepthType Depth
     {
        get { return CvInvoke.cveMatDepth(_ptr); } 
     }
     
     /// <summary>
     /// True if the Mat is empty
     /// </summary>
     public bool IsEmpty
     {
        get { return CvInvoke.cveMatIsEmpty(_ptr); } 
     }
     
     /// <summary>
     /// Number of channels
     /// </summary>
     public int NumberOfChannels
     {
        get { return CvInvoke.cveMatNumberOfChannels(_ptr); } 
     }
     
     /// <summary>
     /// The method removes one or more rows from the bottom of the matrix
     /// </summary>
     public void PopBack(int value)
     {
        CvInvoke.cveMatPopBack(_ptr, value); 
     }
     
     /// <summary>
     /// Adds elements to the bottom of the matrix
     /// </summary>
     public void PushBack(Mat value)
     {
        CvInvoke.cveMatPushBack(_ptr, value); 
     }
     
     /// <summary>
     /// The method returns the number of array elements (a number of pixels if the array represents an image)
     /// </summary>
     public IntPtr Total
     {
        get { return CvInvoke.cveMatTotal(_ptr); } 
     }
     
     /// <summary>
     /// The matrix dimensionality
     /// </summary>
     public int Dims
     {
        get { return CvInvoke.cveMatGetDims(_ptr); } 
     }
     
   }
}